# 语音信号处理实验系统

## 项目简介

本项目是一个完整的语音信号处理实验系统，实现了语音信号的基本分析、处理方法，包括语音信号采集、预处理、分帧加窗、短时时域分析、端点检测和语音识别等核心功能。系统基于Python开发，提供了丰富的可视化和分析工具。

## 主要功能

### 🎯 核心功能
- **语音信号采集** - WAV文件读取和解析
- **预处理** - 分帧、加窗处理
- **时域分析** - 短时能量、平均幅度、过零率计算
- **端点检测** - 基于双门限法的语音段检测
- **语音识别** - 基于时域特征的数字识别（0-9）

### 📊 可视化功能
- **窗函数比较** - 矩形窗、汉明窗、汉宁窗特性对比
- **时域特征分析** - 能量、幅度、过零率可视化
- **端点检测结果** - 语音段检测可视化
- **完整分析报告** - 综合分析结果展示

### 🎨 用户界面
- **交互式菜单** - 友好的命令行界面
- **批量处理** - 支持多个文件批量分析
- **结果保存** - 自动保存分析报告

## 实验指导（引用思源学堂上的实验指导文件）

### 一、实验目的

> 熟悉语音数据的基本形式及特点，理解并应用离散时间信号的基本分析、处理方法，理解语音识别技术的概貌，为后续实验打好基础。

1. 掌握语音信号采集，理解语音信号格式
2. 熟悉语音信号预处理方法
3. 了解语音信号分帧与加窗的重要性和必要性；掌握常用的窗函数和加窗分帧处理的原理；根据原理能编程实现分帧及加窗处理
4. 了解语音短时时域分析的原理；掌握短时时域分析的一些参数计算方法；根据原理能编程实现短时时域分析的参数计算
5. 了解基于双门限法的端点检测原理
6. 掌握并编程实现基于时域分析技术实现孤立字语音识别方法

### 二、实验原理

1. 语音信号采集
2. 语音信号格式的理解
3. 语音信号格式的预处理
4. 语音分帧与加窗
5. 短时时域特性分析
6. 基于双门限法的端点检测
7. 基于时域分析技术实现孤立字语音识别
8. 实验对比及量化分析

### 三、实验内容及要求

1. 语音分帧及加窗
2. 短时时域特性分析
3. 基于双门限法的端点检测
4. 实现时域法语音识别的基本过程，允许对其中的部分环节采用手工交互式的方式来实现，但对于时域分析计算、分类器实现等核心模块应编程实现

## 项目结构

```
dsp/
├── requirements.txt                   # Python依赖包列表
├── README.md                          # 项目主要说明文档
├── PROJECT_STRUCTURE.md               # 项目结构说明（本文件）
├── config.py                          # 系统配置文件
├── main.py                            # 主程序入口，提供交互式菜单
├── speech_processing/                 # 语音处理核心包
│   ├── __init__.py                    # 包初始化，导出主要类
│   ├── core/                          # 核心功能模块
│   │   ├── __init__.py                # 核心模块初始化
│   │   ├── wav_reader.py              # WAV文件读取和解析
│   │   ├── frame_window.py            # 语音分帧和窗函数处理
│   │   ├── time_domain_analysis.py    # 短时时域特性分析
│   │   └── endpoint_detection.py      # 基于双门限法的端点检测
│   └── utils/                         # 工具模块（预留）
│       └── __init__.py
├── examples/                          # 示例程序目录
│   ├── speech_analysis_demo.py        # 综合演示程序（原主程序）
│   ├── basic_usage.py                 # 基础使用示例
│   ├── window_comparison.py           # 窗函数比较示例
│   └── endpoint_detection_demo.py     # 端点检测演示
├── tests/                             # 测试文件目录
│   ├── test_wav_reader.py             # WAV读取功能测试
│   └── test_frame_processor.py        # 分帧处理功能测试
└── data/                              # 数据目录
    ├── audio/                         # 音频文件存储目录
    └── results/                       # 分析结果保存目录
```

## 各目录功能说明

### 根目录文件

- **requirements.txt**: 列出项目所需的Python包及其版本
- **README.md**: 项目的主要说明文档，包含安装、使用、原理等
- **config.py**: 系统配置文件，定义默认参数和常量
- **main.py**: 主程序入口，提供交互式菜单界面

### speech_processing/ 包目录

这是项目的核心包，包含所有语音处理功能：

#### core/ 子目录
包含四个核心功能模块：

1. **wav_reader.py**: WAV文件读取模块
   - `WAVReader` 类：完整的WAV文件读取器
   - `read_wav_file()` 函数：快速读取WAV文件的便捷函数

2. **frame_window.py**: 分帧和加窗模块
   - `FrameProcessor` 类：语音分帧处理器
   - `WindowFunctions` 类：窗函数工具类
   - 支持矩形窗、汉明窗、海宁窗三种窗函数

3. **time_domain_analysis.py**: 时域分析模块
   - `TimeDomainAnalyzer` 类：短时时域特性分析器
   - 计算短时能量、短时平均幅度、短时过零率

4. **endpoint_detection.py**: 端点检测模块
   - `DualThresholdEndpointDetector` 类：双门限法端点检测器
   - 实现语音段的自动检测和提取

#### utils/ 子目录
预留的工具模块目录，用于存放可视化、报告生成等辅助功能。

### examples/ 示例目录

包含各种使用示例：

1. **speech_analysis_demo.py**: 综合演示程序
   - 展示完整的语音处理流程
   - 生成详细的分析报告
   - 提供多种可视化展示

2. **basic_usage.py**: 基础使用示例
   - 演示基本功能的简单用法
   - 适合初学者快速上手

3. **window_comparison.py**: 窗函数比较示例
   - 比较三种窗函数的特性
   - 展示窗函数对语音分析的影响

4. **endpoint_detection_demo.py**: 端点检测演示
   - 演示不同参数下的端点检测效果
   - 提供参数调优指导

### tests/ 测试目录

包含功能测试文件：

1. **test_wav_reader.py**: WAV读取功能测试
2. **test_frame_processor.py**: 分帧处理功能测试

### data/ 数据目录

用于存储项目相关的数据文件：

1. **audio/**: 音频文件目录
   - 存放待分析的WAV文件
   - 建议按类别组织（如数字0-9的语音）

2. **results/**: 分析结果目录
   - 自动保存分析报告
   - 存储可视化图表（如需要）


## 安装和使用

### 环境要求
- Python 3.7+
- NumPy >= 1.21.0
- SciPy >= 1.7.0
- Matplotlib >= 3.4.0

### 1. 创建虚拟环境并安装依赖（建议使用 conda 创建虚拟环境）
```bash
conda create -n dsp1 python=3.10
conda activate dsp1
pip install -r requirements.txt
```

### 2. 数据准备
将WAV文件放入 `data/audio/` 目录

**或者生成测试音频文件：**
```bash
python examples/generate_test_audio.py
```
这将生成14个测试WAV文件，包括：
- 纯音测试文件（440Hz、880Hz）
- 语音模拟文件
- 带静音的语音文件
- 数字语音模拟文件（0-9）

### 3. 运行程序
```bash
python main.py
```

### 4. 选择功能
通过交互式菜单选择需要的功能：
- 基础分析演示
- 窗函数比较
- 端点检测演示
- 完整分析流程
- 运行测试

## 系统功能

### 1. WAV文件读取模块 (`wav_reader.py`)
- 支持多种WAV格式的读取
- 自动解析WAV文件头信息
- 支持不同采样宽度（8位、16位、32位）
- 支持单声道和多声道音频
- 提供详细的文件信息显示

### 2. 语音分帧和加窗模块 (`frame_window.py`)
- 实现三种常用窗函数：
  - 矩形窗（Rectangular Window）
  - 汉明窗（Hamming Window）
  - 海宁窗（Hanning Window）
- 支持可配置的帧长和帧移参数
- 提供窗函数特性对比分析
- 可视化分帧过程

### 3. 短时时域特性分析模块 (`time_domain_analysis.py`)
- 短时能量计算
- 短时平均幅度计算
- 短时过零率计算
- 支持不同窗函数的特征对比
- 浊音清音区域分析

### 4. 端点检测模块 (`endpoint_detection.py`)
- 基于双门限法的端点检测
- 可配置的阈值参数
- 语音段提取功能
- 多种参数组合的对比分析

### 5. 综合演示程序 (`speech_analysis_demo.py`)
- 完整的语音处理流程演示
- 综合分析报告生成
- 交互式文件选择
- 多种可视化展示


## 技术原理

### 1. 语音分帧与加窗
语音信号具有短时平稳性，在10-30ms的时间窗口内可以认为是准稳态过程。分帧处理将长语音信号分割成短帧，每帧应用窗函数以减少频谱泄漏。

**窗函数特性对比：**
- 矩形窗：主瓣窄，旁瓣高，适用于时域分析
- 汉明窗：主瓣较宽，旁瓣低，适用于语音分析
- 海宁窗：主瓣最宽，旁瓣中等，适用于频谱分析

### 2. 短时时域特征
- **短时能量**：E(n) = Σ[x(m)]²，反映语音信号的强度
- **短时平均幅度**：M(n) = Σ|x(m)|，反映语音信号的幅度变化
- **短时过零率**：Z(n) = (1/2N) × Σ|sgn[x(m)] - sgn[x(m-1)]|，反映信号的频率特性

### 3. 双门限法端点检测
使用两个阈值进行端点检测：
- 高阈值：基于短时能量，用于检测明显的语音段
- 低阈值：结合短时能量和过零率，用于检测微弱的语音段

## 实验步骤

### 1. 语音信号采集
- 录制"0"、"1"、...、"9"这10个数字的语音
- 每个数字录制10组以上样本
- 保存为WAV格式文件

### 2. WAV格式分析
- 使用`wav_reader.py`读取WAV文件
- 分析文件头信息，理解采样率、声道数等参数
- 验证音频数据的正确性

### 3. 分帧加窗实验
- 使用不同窗函数处理同一段语音
- 对比三种窗函数的时域和频域特性
- 分析窗函数对语音特征的影响

### 4. 时域特征提取
- 计算短时能量、短时平均幅度、短时过零率
- 分析不同窗函数下的特征差异
- 识别浊音和清音区域

### 5. 端点检测实验
- 使用双门限法进行端点检测
- 调整阈值参数，观察检测效果
- 提取语音段进行后续分析

## 实验结果示例

运行演示程序后，系统会生成：
1. 完整的可视化分析图表
2. 详细的数值分析报告
3. 不同参数下的对比分析
4. 语音段提取结果

## 注意事项

1. 确保WAV文件格式正确，支持常见的采样率（8kHz、16kHz、44.1kHz等）
2. 将WAV文件放在 `data/audio` 目录下
3. 建议使用较短的语音片段进行实验，以便观察细节
4. 分析结果会自动保存到 `data/results` 目录
5. 所有模块都使用相对导入，确保包结构正确
6. 配置文件 `config.py` 集中管理所有默认参数
7. 数据文件统一存放在 `data/` 目录下

### 中文字体显示问题

如果matplotlib图形中的中文显示为方块，可以尝试以下解决方案：

1. **使用英文版本示例**：
   ```bash
   python examples/simple_demo.py
   python examples/window_comparison_english.py
   ```

2. **安装中文字体包**（Windows）：
   - 系统通常已包含SimHei、Microsoft YaHei等字体
   - 如果仍有问题，可以手动安装字体

3. **使用非交互式后端**：
   ```python
   import matplotlib
   matplotlib.use('Agg')  # 使用非交互式后端
   ```

4. **保存图片而非显示**：
   ```python
   plt.savefig('result.png', dpi=300, bbox_inches='tight')
   ```

## 扩展功能

系统设计具有良好的扩展性，可以方便地添加：
- 频域分析功能（FFT、功率谱密度等）
- 更多时域特征（自相关、互相关等）
- 高级端点检测算法
- 语音识别相关功能

## 技术支持

如有问题或建议，请参考代码注释或联系开发者。

---

## 语音识别详细指南

### 为什么需要训练？

语音识别需要训练的原因：

1. **特征学习**：每个数字（0-9）都有独特的声学特征
   - 不同数字的发音方式不同
   - 频率成分、能量分布、过零率等特征各异
   - 需要通过学习建立"数字→特征"的映射关系

2. **个体差异**：不同说话人的语音特征不同
   - 音调高低、语速快慢、发音习惯的差异
   - 需要多个样本建立鲁棒的特征模板

3. **环境适应**：不同录音环境的影响
   - 背景噪声、录音设备、距离等因素
   - 训练数据需要包含这些变化

4. **模板建立**：建立每个数字的"标准模板"
   - 计算每个数字特征的平均值和标准差
   - 用于后续的相似度匹配

### 训练过程

1. **数据收集**：收集每个数字的多个语音样本
2. **特征提取**：从每个样本中提取时域特征
3. **模板计算**：计算每个数字特征的平均值和分布
4. **模型保存**：保存特征模板用于识别

### 识别过程

1. **特征提取**：从待识别语音中提取相同特征
2. **相似度计算**：与所有数字模板计算相似度
3. **结果选择**：选择相似度最高的数字作为结果
4. **置信度评估**：评估识别结果的可靠性

### 快速体验（无需训练）

如果您想快速体验语音识别功能，系统提供了**特征提取演示**：

```bash
python main.py
# 选择 5 - 语音识别演示
```

系统会：
- 自动分析现有音频文件的特征
- 显示每个文件的时域特征值
- 展示不同数字的特征差异

### 完整训练流程

要进行完整的语音识别训练：

1. **准备数据**
   ```
   data/
   ├── train/
   │   ├── digit_0/  # 数字0的训练样本
   │   ├── digit_1/  # 数字1的训练样本
   │   └── ...
   └── test/
       ├── digit_0/  # 数字0的测试样本
       └── ...
   ```

2. **运行训练**
   ```bash
   python main.py
   # 选择 5 - 语音识别演示
   ```

3. **查看结果**
   - 训练进度和样本统计
   - 测试准确率
   - 交互式识别功能

### 特征说明

系统提取的时域特征包括：

- **能量特征**：最大能量、平均能量、能量标准差
- **幅度特征**：最大幅度、平均幅度、幅度标准差  
- **过零率特征**：最大过零率、平均过零率、过零率标准差
- **其他特征**：语音时长、能量比、幅度比

### 性能优化建议

1. **数据质量**：使用清晰的语音样本，避免背景噪声
2. **数据多样性**：包含不同说话人、语速、音量的样本
3. **样本数量**：每个数字至少5-10个训练样本
4. **特征调优**：可以调整特征权重或添加新特征

## 分类器对比分析

### 支持的分类器

系统支持以下5种分类器算法：

1. **朴素贝叶斯 (Naive Bayesian)**
   - 基于贝叶斯定理和特征独立假设
   - 优点：训练快速、对噪声鲁棒、内存占用小
   - 缺点：假设特征独立、可能欠拟合
   - 适用场景：小数据集、快速原型

2. **Fisher线性判别 (Fisher Linear Discriminant)**
   - 基于线性判别分析
   - 优点：计算效率高、降维效果好、理论成熟
   - 缺点：假设高斯分布、只能处理线性边界
   - 适用场景：线性可分数据、需要降维

3. **决策树 (Decision Tree)**
   - 基于树状结构的分类方法
   - 优点：可解释性强、处理非线性、无需特征缩放
   - 缺点：容易过拟合、对噪声敏感、不稳定
   - 适用场景：需要可解释性、处理非线性关系

4. **支持向量机 (Support Vector Machine)**
   - 基于统计学习理论的分类方法
   - 优点：泛化能力强、适合高维数据、内存效率高
   - 缺点：参数敏感、大数据集训练慢、黑盒模型
   - 适用场景：高维特征、复杂边界、需要强泛化能力

5. **K近邻 (K-Nearest Neighbors)**
   - 基于实例的学习方法
   - 优点：非参数方法、适合复杂边界、简单直观
   - 缺点：计算复杂度高、对维度敏感、需要大量内存
   - 适用场景：小数据集、复杂模式、非参数方法

### 分类器选择建议

根据实验需求选择分类器：

- **追求最高准确率**：支持向量机
- **需要快速训练**：朴素贝叶斯
- **需要可解释性**：决策树
- **数据线性可分**：Fisher线性判别
- **数据量小且模式复杂**：K近邻

### 使用方法

```bash
python main.py
# 选择 6 - 分类器对比分析
```

系统会：
1. 训练所有分类器
2. 在测试数据上评估性能
3. 生成详细的对比报告
4. 提供分类器选择建议
5. 支持交互式识别测试

### 对比报告内容

- **总体性能对比**：准确率、置信度、训练状态
- **各数字识别准确率**：每个数字在不同分类器下的表现
- **分类器特点分析**：优缺点和适用场景
- **选择建议**：基于性能的推荐理由

---

**开发环境：** Python 3.8+  
**测试平台：** Windows 11, Ubuntu 22.04  
**开发者：** 周湛昊
**更新时间：** 2025年9月26日
